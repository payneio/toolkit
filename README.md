# Personal Toolkit Framework

A structured approach to managing personal utility scripts following the Unix philosophy while leveraging Python's ecosystem.

## Philosophy

This framework follows key Unix philosophy principles:

1. **Each tool does one thing well** - Create small, focused utilities
2. **Use text streams as universal interface** - Tools accept stdin and output to stdout
3. **Compose tools through pipes** - Chain tools together for complex workflows
4. **Make it easy to combine tools** - Standardized formats (JSON, YAML) for data exchange

While maintaining the simplicity of Unix tools, we leverage Python's rich ecosystem for more complex functionality, managed through UV for dependency management.

## Directory Structure

```
~/toolkit/
├── bin/              # Launcher scripts (auto-generated by make)
├── templates/        # Templates for auto-generated files
│   ├── bin_launcher.sh.template   # Template for bin launchers
│   └── man.template               # Template for man pages
├── tools/            # Individual utilities organized by category
│   ├── document/     # Document-related tools
│   │   ├── docx2md.py            # Tool implementation
│   │   ├── docx2md.1             # Man page (auto-generated)
│   │   └── tools.toml            # Tool configuration
│   ├── gpt/          # GPT-related tools
│   │   ├── gpt.py                # Tool implementation
│   │   ├── gpt.1                 # Man page (auto-generated)
│   │   └── tools.toml            # Tool configuration
│   └── toolkit/      # Core toolkit tools
│       ├── toolkit.py            # Tool implementation
│       ├── toolkit.1             # Man page (auto-generated)
│       └── tools.toml            # Tool configuration
├── src/              # Shared library code
│   └── myscripts/    
│       └── __init__.py
├── tests/            # Test directory
│   ├── test_echo.py
│   └── test_gpt.py
├── Makefile          # Build system and automation
├── pyproject.toml    # Project metadata and dependencies
└── README.md         # This file
```

## Setup

### Prerequisites

- Python 3.8+
- [UV](https://github.com/astral-sh/uv) package manager

### Installation

1. Clone this repository:
   ```bash
   git clone https://github.com/yourusername/toolkit.git ~/toolkit
   ```

2. Build and install tools:
   ```bash
   cd ~/toolkit
   make all
   ```

3. Ensure `~/.local/bin` is in your PATH:
   ```bash
   echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
   ```

### System Dependencies

Some tools require system packages to be installed separately:

#### Document Tools

- **md2pdf**: Requires LaTeX for PDF generation
  ```bash
  sudo apt install texlive-latex-base texlive-latex-extra
  ```

- **pdf2md**: Requires poppler-utils and pandoc
  ```bash
  sudo apt install poppler-utils pandoc
  ```

- **docx2md**: Requires pandoc
  ```bash
  sudo apt install pandoc
  ```

These dependencies are listed in each tool's `tools.toml` configuration under the `system_dependencies` field.

## Creating New Utilities

The toolkit provides a simple workflow for creating new utilities using the `make` system.

### Creating a new tool with the make system

The easiest way to create a new tool is to use the `new-tool` make target:

```bash
cd ~/toolkit
make new-tool name=newtool
```

This will:
1. Create the tool directory structure
2. Add a template Python script with proper docstrings
3. Create the tools.toml configuration file
4. Generate the man page
5. Create the bin launcher script

## Tools Configuration System

The toolkit uses TOML configuration files to define and manage tools. This approach provides several advantages:

1. **Single Source of Truth**: Tool metadata is stored in one place
2. **Automation**: Automatically generate launcher scripts and man pages
3. **Discoverability**: Tools can be discovered and documented programmatically
4. **Maintainability**: Easy to update or add information about tools

### Tool Configuration File (tools.toml)

Each tool category directory includes a `tools.toml` configuration file that defines one or more tools:

```toml
[tool]
command = "mytool"
script = "mytool/mytool.py"
description = "Description of the tool"
version = "1.0.0"
system_dependencies = ["optional-system-dependency"]
```

Fields in the tools.toml file:

| Field | Description |
|-------|-------------|
| `command` | The command name that will be used to invoke the tool |
| `script` | Path to the Python script (relative to tools directory) |
| `description` | Short description of what the tool does |
| `version` | Tool version number |
| `system_dependencies` | List of system dependencies (not Python packages) |

This configuration is used by the `make` system to:

1. Generate bin launcher scripts that handle path resolution and dependency management
2. Create man pages with consistent formatting
3. Provide information to the `toolkit` discovery command

### Multiple Tools in One Category

A single tools.toml file can define multiple related tools:

```toml
[tool]
command = "calendar-add"
script = "calendar/add.py"
description = "Add an event to the calendar"
version = "1.0.0"

[tool]
command = "calendar-list"
script = "calendar/list.py"
description = "List calendar events"
version = "1.0.0"
```

### Tool Implementation Pattern

A typical tool follows this pattern:

```python
#!/usr/bin/env python3
"""
mytool: Description of the tool

Detailed explanation of what the tool does.

Usage: mytool [options]

Examples:
  mytool input.txt           # Process a file
  cat input.txt | mytool     # Process stdin
"""
import sys
import argparse

def main():
    parser = argparse.ArgumentParser(description="Tool description")
    parser.add_argument('input', nargs='?', help="Input file (default: stdin)")
    parser.add_argument('-v', '--version', action='version', version='mytool 1.0.0')
    args = parser.parse_args()
    
    # Read from stdin or file
    if args.input:
        with open(args.input) as f:
            data = f.read()
    else:
        data = sys.stdin.read()
    
    # Process data
    result = process_data(data)
    
    # Output results to stdout
    print(result)
    return 0

if __name__ == "__main__":
    sys.exit(main())
```

### Adding Dependencies

Add any new dependencies to `pyproject.toml` and then run `make build`:

```toml
[project]
name = "toolkit"
version = "0.1.0"
dependencies = [
  "requests>=2.28.0",
  "beautifulsoup4>=4.11.0",
  "toml>=0.10.2",
  # Add new dependencies here
]

[project.optional-dependencies]
dev = [
  "pytest>=7.0.0",
  "ruff>=0.11.4",
]
```

## Usage Patterns

### Basic usage

Run any utility by its name:

```bash
cal-add
cal-list
fetch-email
```

### Piping between utilities

Chain tools together using Unix pipes:

```bash
# Extract events from email and add to calendar
fetch-email | extract-events | cal-add

# With filtering
fetch-email | grep "important" | extract-events | cal-add
```

### Using files as intermediate storage

```bash
# Save outputs to files
fetch-email > emails.json
extract-events < emails.json > events.json
cal-add < events.json
```

### Running with cron

```
# Run daily at 9am
0 9 * * * $HOME/.local/bin/fetch-email | $HOME/.local/bin/extract-events | $HOME/.local/bin/cal-add > $HOME/logs/schedule-$(date +\%Y\%m\%d).log 2>&1
```

## Managing Complexity

As your collection grows to hundreds or thousands of utilities:

1. **Categorize by domain**: Group related tools in subdirectories
2. **Use consistent interfaces**: Standardize on input/output formats
3. **Share code**: Move common functionality to the `src/` directory
4. **Document well**: Maintain clear usage examples for each tool
5. **Consistent naming**: Establish naming patterns (e.g., `domain-verb`)

## Makefile Build System

The toolkit uses a Makefile to automate common tasks, making it easy to maintain and extend the toolkit.

### Makefile Targets

| Target | Description |
|--------|-------------|
| `make all` | Run all tasks (bin, man, install, build) |
| `make bin` | Generate bin launcher scripts from tools.toml |
| `make man` | Generate man pages from tools.toml |
| `make build` | Sync dependencies with UV |
| `make check` | Run linting with Ruff |
| `make install` | Install both links and man pages |
| `make install-links` | Install symlinks to ~/.local/bin |
| `make install-docs` | Install man pages to ~/.local/share/man/man1 |
| `make clean` | Clean up generated files |
| `make new-tool name=toolname` | Create a new tool |

### How the Build System Works

1. **Tool Discovery**: The Makefile finds all tools.toml files in the tools directory
2. **Template-based Generation**: Uses templates to generate bin launchers and man pages
3. **Dependency Management**: Integrates with UV for Python dependency management
4. **Installation**: Creates symlinks and installs documentation

### Example Development Workflow

```bash
# Navigate to toolkit directory
cd ~/toolkit

# Create a new tool
make new-tool name=mynewcalc

# Edit the tool implementation
vim tools/mynewcalc/mynewcalc.py

# Update tool description in tools.toml
vim tools/mynewcalc/tools.toml

# Regenerate binaries and man pages
make bin man

# Run linting to ensure code quality
make check

# Install the tool
make install

# Test your tool
mynewcalc --help
```

You can also run tests with:

```bash
uvx pytest
```

## Tool Discovery and Help

The toolkit includes a built-in help system to discover and learn about available tools:

```bash
# List all available tools
toolkit

# Get detailed information about a specific tool
toolkit --info gpt

# Get JSON output of all tools
toolkit --json

# Get verbose output with dependencies
toolkit --verbose
```

## Templates System

The toolkit uses templates for generating files automatically:

### bin_launcher.sh.template

This template is used to generate the shell script launchers in the bin directory:

```bash
#!/usr/bin/env bash

# Find the toolkit repository directory
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
TOOLKIT_DIR="$(dirname "$SCRIPT_DIR")"

# Tool information 
TOOL_SCRIPT="$TOOLKIT_DIR/tools/{{TOOL_SCRIPT}}"

# Check if the tool script exists
if [ ! -f "$TOOL_SCRIPT" ]; then
    echo "Error: Tool script not found at $TOOL_SCRIPT"
    exit 1
fi

# Run the tool script using UV for dependency management
uv run --project-dir "$TOOLKIT_DIR" "$TOOL_SCRIPT" "$@"
```

### man.template

This template is used to generate basic man pages for each tool. Note that these are just stubs - the Makefile is designed to never overwrite existing man pages, so tool developers can create detailed manual pages that won't be lost during rebuilds.

```
.TH {{COMMAND_UPPER}} 1 "{{DATE}}" "Toolkit" "User Commands"
.SH NAME
{{command}} \- {{description}}
.SH SYNOPSIS
.B {{command}}
[\fIOPTIONS\fR]
.SH DESCRIPTION
{{description}}
.SH OPTIONS
.TP
.B \-\-help
Show help message and exit.
.TP
.B \-\-version
Show version information and exit.
.SH EXAMPLES
.PP
{{command}} --help
.SH SEE ALSO
.BR toolkit (1)
```

These auto-generated man pages are basic stubs. When developing serious tools, you should replace them with detailed documentation. Once you've created a custom man page, the `make man` command will respect your changes and won't overwrite your file.
